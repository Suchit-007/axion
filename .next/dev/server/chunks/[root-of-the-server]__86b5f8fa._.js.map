{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nlet MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/maintenance-platform';\r\n\r\nif (!MONGODB_URI) {\r\n  throw new Error('Please define the MONGODB_URI environment variable');\r\n}\r\n\r\n// Ensure database name is in the connection string\r\n// MongoDB Atlas connection strings sometimes don't include database name\r\nif (MONGODB_URI.includes('mongodb+srv://') || MONGODB_URI.includes('mongodb://')) {\r\n  // Check if database name is missing (connection string ends with / or has ? but no database)\r\n  const hasQueryParams = MONGODB_URI.includes('?');\r\n  const pathMatch = MONGODB_URI.match(/@[^\\/]+(\\/[^?]*)?(\\?|$)/);\r\n  \r\n  if (!pathMatch || !pathMatch[1] || pathMatch[1] === '/') {\r\n    // Database name is missing, add it\r\n    const dbName = 'maintenance-platform';\r\n    if (hasQueryParams) {\r\n      // Insert database name before query params\r\n      MONGODB_URI = MONGODB_URI.replace(/(@[^\\/]+)\\/?(?=\\?)/, `$1/${dbName}`);\r\n    } else {\r\n      // Append database name at the end\r\n      if (MONGODB_URI.endsWith('/')) {\r\n        MONGODB_URI = MONGODB_URI + dbName;\r\n      } else {\r\n        MONGODB_URI = MONGODB_URI + '/' + dbName;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface MongooseCache {\r\n  conn: typeof mongoose | null;\r\n  promise: Promise<typeof mongoose> | null;\r\n}\r\n\r\ndeclare global {\r\n  var mongoose: MongooseCache | undefined;\r\n}\r\n\r\nlet cached: MongooseCache = global.mongoose || {\r\n  conn: null,\r\n  promise: null,\r\n};\r\n\r\nif (!global.mongoose) {\r\n  global.mongoose = cached;\r\n}\r\n\r\nasync function connectDB() {\r\n  if (cached.conn) {\r\n    return cached.conn;\r\n  }\r\n\r\n  if (!cached.promise) {\r\n    const opts = {\r\n      bufferCommands: false,\r\n    };\r\n\r\n    try {\r\n      cached.promise = mongoose.connect(MONGODB_URI, opts);\r\n    } catch (error) {\r\n      cached.promise = null;\r\n      console.error('MongoDB connection setup error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  try {\r\n    cached.conn = await cached.promise;\r\n    console.log('MongoDB connected successfully');\r\n    return cached.conn;\r\n  } catch (error: any) {\r\n    cached.promise = null;\r\n    console.error('MongoDB connection error:', error.message);\r\n    throw new Error(`Failed to connect to MongoDB: ${error.message}`);\r\n  }\r\n}\r\n\r\nexport default connectDB;\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE7C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA,mDAAmD;AACnD,yEAAyE;AACzE,IAAI,YAAY,QAAQ,CAAC,qBAAqB,YAAY,QAAQ,CAAC,eAAe;IAChF,6FAA6F;IAC7F,MAAM,iBAAiB,YAAY,QAAQ,CAAC;IAC5C,MAAM,YAAY,YAAY,KAAK,CAAC;IAEpC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,IAAI,SAAS,CAAC,EAAE,KAAK,KAAK;QACvD,mCAAmC;QACnC,MAAM,SAAS;QACf,IAAI,gBAAgB;YAClB,2CAA2C;YAC3C,cAAc,YAAY,OAAO,CAAC,sBAAsB,CAAC,GAAG,EAAE,QAAQ;QACxE,OAAO;YACL,kCAAkC;YAClC,IAAI,YAAY,QAAQ,CAAC,MAAM;gBAC7B,cAAc,cAAc;YAC9B,OAAO;gBACL,cAAc,cAAc,MAAM;YACpC;QACF;IACF;AACF;AAWA,IAAI,SAAwB,OAAO,QAAQ,IAAI;IAC7C,MAAM;IACN,SAAS;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,EAAE;IACpB,OAAO,QAAQ,GAAG;AACpB;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,IAAI;YACF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAa;QACjD,EAAE,OAAO,OAAO;YACd,OAAO,OAAO,GAAG;YACjB,QAAQ,KAAK,CAAC,mCAAmC;YACjD,MAAM;QACR;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QAClC,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAY;QACnB,OAAO,OAAO,GAAG;QACjB,QAAQ,KAAK,CAAC,6BAA6B,MAAM,OAAO;QACxD,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,MAAM,OAAO,EAAE;IAClE;AACF;uCAEe"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IUser extends Document {\r\n  email: string;\r\n  name: string;\r\n  password: string;\r\n  role: 'student' | 'staff' | 'technician' | 'admin';\r\n  phone?: string;\r\n  location?: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst UserSchema: Schema = new Schema(\r\n  {\r\n    email: { \r\n      type: String, \r\n      required: true, \r\n      unique: true,\r\n      lowercase: true,\r\n      trim: true\r\n    },\r\n    name: { \r\n      type: String, \r\n      required: true \r\n    },\r\n    password: { \r\n      type: String, \r\n      required: true \r\n    },\r\n    role: { \r\n      type: String, \r\n      enum: ['student', 'staff', 'technician', 'admin'],\r\n      default: 'student'\r\n    },\r\n    phone: { \r\n      type: String \r\n    },\r\n    location: { \r\n      type: String \r\n    },\r\n    isActive: { \r\n      type: Boolean, \r\n      default: true \r\n    }\r\n  },\r\n  { \r\n    timestamps: true \r\n  }\r\n);\r\n\r\nexport default mongoose.models.User || mongoose.model<IUser>('User', UserSchema);\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAcA,MAAM,aAAqB,IAAI,mHAAM,CACnC;IACE,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,UAAU;IACZ;IACA,UAAU;QACR,MAAM;QACN,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,MAAM;YAAC;YAAW;YAAS;YAAc;SAAQ;QACjD,SAAS;IACX;IACA,OAAO;QACL,MAAM;IACR;IACA,UAAU;QACR,MAAM;IACR;IACA,UAAU;QACR,MAAM;QACN,SAAS;IACX;AACF,GACA;IACE,YAAY;AACd;uCAGa,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport connectDB from \"./db\";\r\nimport User from \"@/models/User\";\r\n\r\nexport const authOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"email\" },\r\n        password: { label: \"Password\", type: \"password\" },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.password) {\r\n          return null;\r\n        }\r\n\r\n        await connectDB();\r\n\r\n        const user = await User.findOne({\r\n          email: credentials.email.toLowerCase(),\r\n          isActive: true,\r\n        });\r\n\r\n        if (!user) {\r\n          return null;\r\n        }\r\n\r\n        const isPasswordValid = await bcrypt.compare(\r\n          credentials.password as string,\r\n          user.password\r\n        );\r\n\r\n        if (!isPasswordValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: user._id.toString(),\r\n          email: user.email,\r\n          name: user.name,\r\n          role: user.role,\r\n        };\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }: { token: any; user?: any }) {\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.role = user.role;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }: { session: any; token: any }) {\r\n      if (session.user) {\r\n        session.user.id = token.id || token.sub;\r\n        session.user.role = token.role;\r\n      }\r\n      return session;\r\n    },\r\n  },\r\n  pages: {\r\n    signIn: \"/login\",\r\n  },\r\n  session: {\r\n    strategy: \"jwt\" as const,\r\n  },\r\n};\r\n\r\n// Export auth functions separately for client-side use\r\nexport const { auth, signIn, signOut } = NextAuth(authOptions);\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,MAAM,cAAc;IACzB,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,IAAA,6HAAS;gBAEf,MAAM,OAAO,MAAM,kIAAI,CAAC,OAAO,CAAC;oBAC9B,OAAO,YAAY,KAAK,CAAC,WAAW;oBACpC,UAAU;gBACZ;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,8IAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;oBACrB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAA8B;YACnD,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;YACxB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAgC;YAC5D,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE,IAAI,MAAM,GAAG;gBACvC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;IACZ;AACF;AAGO,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,kJAAQ,EAAC"}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/models/Incident.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IIncident extends Document {\r\n  title: string;\r\n  category: 'electricity' | 'water' | 'internet' | 'hostel' | 'garbage' | 'it' | 'equipment';\r\n  description: string;\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n  status: 'new' | 'in-progress' | 'resolved' | 'closed';\r\n  location: {\r\n    latitude: number;\r\n    longitude: number;\r\n    address?: string;\r\n  };\r\n  images: string[];\r\n  reportedBy: mongoose.Types.ObjectId;\r\n  assignedTo?: mongoose.Types.ObjectId;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  resolvedAt?: Date;\r\n}\r\n\r\nconst IncidentSchema: Schema = new Schema(\r\n  {\r\n    title: { \r\n      type: String, \r\n      required: true,\r\n      trim: true\r\n    },\r\n    category: { \r\n      type: String, \r\n      enum: ['electricity', 'water', 'internet', 'hostel', 'garbage', 'it', 'equipment'],\r\n      required: true\r\n    },\r\n    description: { \r\n      type: String, \r\n      required: true \r\n    },\r\n    priority: { \r\n      type: String, \r\n      enum: ['low', 'medium', 'high', 'critical'],\r\n      default: 'medium'\r\n    },\r\n    status: { \r\n      type: String, \r\n      enum: ['new', 'in-progress', 'resolved', 'closed'],\r\n      default: 'new'\r\n    },\r\n    location: {\r\n      latitude: { type: Number, required: true },\r\n      longitude: { type: Number, required: true },\r\n      address: { type: String }\r\n    },\r\n    images: [{ \r\n      type: String \r\n    }],\r\n    reportedBy: { \r\n      type: Schema.Types.ObjectId, \r\n      ref: 'User', \r\n      required: true \r\n    },\r\n    assignedTo: { \r\n      type: Schema.Types.ObjectId, \r\n      ref: 'User' \r\n    },\r\n    resolvedAt: { \r\n      type: Date \r\n    }\r\n  },\r\n  { \r\n    timestamps: true \r\n  }\r\n);\r\n\r\n// Index for duplicate detection\r\nIncidentSchema.index({ \r\n  'location.latitude': 1, \r\n  'location.longitude': 1, \r\n  category: 1, \r\n  status: 1 \r\n});\r\n\r\nexport default mongoose.models.Incident || mongoose.model<IIncident>('Incident', IncidentSchema);\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAqBA,MAAM,iBAAyB,IAAI,mHAAM,CACvC;IACE,OAAO;QACL,MAAM;QACN,UAAU;QACV,MAAM;IACR;IACA,UAAU;QACR,MAAM;QACN,MAAM;YAAC;YAAe;YAAS;YAAY;YAAU;YAAW;YAAM;SAAY;QAClF,UAAU;IACZ;IACA,aAAa;QACX,MAAM;QACN,UAAU;IACZ;IACA,UAAU;QACR,MAAM;QACN,MAAM;YAAC;YAAO;YAAU;YAAQ;SAAW;QAC3C,SAAS;IACX;IACA,QAAQ;QACN,MAAM;QACN,MAAM;YAAC;YAAO;YAAe;YAAY;SAAS;QAClD,SAAS;IACX;IACA,UAAU;QACR,UAAU;YAAE,MAAM;YAAQ,UAAU;QAAK;QACzC,WAAW;YAAE,MAAM;YAAQ,UAAU;QAAK;QAC1C,SAAS;YAAE,MAAM;QAAO;IAC1B;IACA,QAAQ;QAAC;YACP,MAAM;QACR;KAAE;IACF,YAAY;QACV,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,YAAY;QACV,MAAM,mHAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;IACP;IACA,YAAY;QACV,MAAM;IACR;AACF,GACA;IACE,YAAY;AACd;AAGF,gCAAgC;AAChC,eAAe,KAAK,CAAC;IACnB,qBAAqB;IACrB,sBAAsB;IACtB,UAAU;IACV,QAAQ;AACV;uCAEe,oHAAQ,CAAC,MAAM,CAAC,QAAQ,IAAI,oHAAQ,CAAC,KAAK,CAAY,YAAY"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/app/api/incidents/user/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/lib/auth\";\r\nimport connectDB from \"@/lib/db\";\r\nimport Incident from \"@/models/Incident\";\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    // Get user session using getServerSession (more reliable for API routes)\r\n    const session = await getServerSession(authOptions);\r\n\r\n    if (!session || !session.user || !session.user.id) {\r\n      return NextResponse.json(\r\n        { message: \"Unauthorized - Please log in\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    await connectDB();\r\n\r\n    const { searchParams } = new URL(request.url);\r\n    const status = searchParams.get(\"status\");\r\n    const search = searchParams.get(\"search\");\r\n    const limit = parseInt(searchParams.get(\"limit\") || \"20\");\r\n    const skip = parseInt(searchParams.get(\"skip\") || \"0\");\r\n\r\n    // Build query for user's incidents\r\n    const query: any = {\r\n      reportedBy: session.user.id,\r\n    };\r\n\r\n    if (status) {\r\n      query.status = status;\r\n    }\r\n\r\n    if (search) {\r\n      query.$or = [\r\n        { title: { $regex: search, $options: \"i\" } },\r\n        { category: { $regex: search, $options: \"i\" } },\r\n        { description: { $regex: search, $options: \"i\" } },\r\n      ];\r\n    }\r\n\r\n    const incidents = await Incident.find(query)\r\n      .populate(\"assignedTo\", \"name email\")\r\n      .sort({ createdAt: -1 })\r\n      .limit(limit)\r\n      .skip(skip)\r\n      .lean();\r\n\r\n    const total = await Incident.countDocuments(query);\r\n\r\n    return NextResponse.json({\r\n      incidents,\r\n      total,\r\n      limit,\r\n      skip,\r\n      hasMore: skip + limit < total,\r\n    });\r\n  } catch (error: any) {\r\n    console.error(\"Get user incidents error:\", error);\r\n    return NextResponse.json(\r\n      {\r\n        message: \"Error fetching incidents\",\r\n        error:\r\n          process.env.NODE_ENV === \"development\" ? error.message : undefined,\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,yEAAyE;QACzE,MAAM,UAAU,MAAM,IAAA,2JAAgB,EAAC,mIAAW;QAElD,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,EAAE,EAAE;YACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;YAA+B,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,IAAA,6HAAS;QAEf,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QACpD,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAElD,mCAAmC;QACnC,MAAM,QAAa;YACjB,YAAY,QAAQ,IAAI,CAAC,EAAE;QAC7B;QAEA,IAAI,QAAQ;YACV,MAAM,MAAM,GAAG;QACjB;QAEA,IAAI,QAAQ;YACV,MAAM,GAAG,GAAG;gBACV;oBAAE,OAAO;wBAAE,QAAQ;wBAAQ,UAAU;oBAAI;gBAAE;gBAC3C;oBAAE,UAAU;wBAAE,QAAQ;wBAAQ,UAAU;oBAAI;gBAAE;gBAC9C;oBAAE,aAAa;wBAAE,QAAQ;wBAAQ,UAAU;oBAAI;gBAAE;aAClD;QACH;QAEA,MAAM,YAAY,MAAM,sIAAQ,CAAC,IAAI,CAAC,OACnC,QAAQ,CAAC,cAAc,cACvB,IAAI,CAAC;YAAE,WAAW,CAAC;QAAE,GACrB,KAAK,CAAC,OACN,IAAI,CAAC,MACL,IAAI;QAEP,MAAM,QAAQ,MAAM,sIAAQ,CAAC,cAAc,CAAC;QAE5C,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB;YACA;YACA;YACA;YACA,SAAS,OAAO,QAAQ;QAC1B;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OACE,uCAAyC,MAAM,OAAO,GAAG;QAC7D,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}