{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nlet MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/maintenance-platform';\r\n\r\nif (!MONGODB_URI) {\r\n  throw new Error('Please define the MONGODB_URI environment variable');\r\n}\r\n\r\n// Ensure database name is in the connection string\r\n// MongoDB Atlas connection strings sometimes don't include database name\r\nif (MONGODB_URI.includes('mongodb+srv://') || MONGODB_URI.includes('mongodb://')) {\r\n  // Check if database name is missing (connection string ends with / or has ? but no database)\r\n  const hasQueryParams = MONGODB_URI.includes('?');\r\n  const pathMatch = MONGODB_URI.match(/@[^\\/]+(\\/[^?]*)?(\\?|$)/);\r\n  \r\n  if (!pathMatch || !pathMatch[1] || pathMatch[1] === '/') {\r\n    // Database name is missing, add it\r\n    const dbName = 'maintenance-platform';\r\n    if (hasQueryParams) {\r\n      // Insert database name before query params\r\n      MONGODB_URI = MONGODB_URI.replace(/(@[^\\/]+)\\/?(?=\\?)/, `$1/${dbName}`);\r\n    } else {\r\n      // Append database name at the end\r\n      if (MONGODB_URI.endsWith('/')) {\r\n        MONGODB_URI = MONGODB_URI + dbName;\r\n      } else {\r\n        MONGODB_URI = MONGODB_URI + '/' + dbName;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface MongooseCache {\r\n  conn: typeof mongoose | null;\r\n  promise: Promise<typeof mongoose> | null;\r\n}\r\n\r\ndeclare global {\r\n  var mongoose: MongooseCache | undefined;\r\n}\r\n\r\nlet cached: MongooseCache = global.mongoose || {\r\n  conn: null,\r\n  promise: null,\r\n};\r\n\r\nif (!global.mongoose) {\r\n  global.mongoose = cached;\r\n}\r\n\r\nasync function connectDB() {\r\n  if (cached.conn) {\r\n    return cached.conn;\r\n  }\r\n\r\n  if (!cached.promise) {\r\n    const opts = {\r\n      bufferCommands: false,\r\n    };\r\n\r\n    try {\r\n      cached.promise = mongoose.connect(MONGODB_URI, opts);\r\n    } catch (error) {\r\n      cached.promise = null;\r\n      console.error('MongoDB connection setup error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  try {\r\n    cached.conn = await cached.promise;\r\n    console.log('MongoDB connected successfully');\r\n    return cached.conn;\r\n  } catch (error: any) {\r\n    cached.promise = null;\r\n    console.error('MongoDB connection error:', error.message);\r\n    throw new Error(`Failed to connect to MongoDB: ${error.message}`);\r\n  }\r\n}\r\n\r\nexport default connectDB;\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE7C,IAAI,CAAC,aAAa;IAChB,MAAM,IAAI,MAAM;AAClB;AAEA,mDAAmD;AACnD,yEAAyE;AACzE,IAAI,YAAY,QAAQ,CAAC,qBAAqB,YAAY,QAAQ,CAAC,eAAe;IAChF,6FAA6F;IAC7F,MAAM,iBAAiB,YAAY,QAAQ,CAAC;IAC5C,MAAM,YAAY,YAAY,KAAK,CAAC;IAEpC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,IAAI,SAAS,CAAC,EAAE,KAAK,KAAK;QACvD,mCAAmC;QACnC,MAAM,SAAS;QACf,IAAI,gBAAgB;YAClB,2CAA2C;YAC3C,cAAc,YAAY,OAAO,CAAC,sBAAsB,CAAC,GAAG,EAAE,QAAQ;QACxE,OAAO;YACL,kCAAkC;YAClC,IAAI,YAAY,QAAQ,CAAC,MAAM;gBAC7B,cAAc,cAAc;YAC9B,OAAO;gBACL,cAAc,cAAc,MAAM;YACpC;QACF;IACF;AACF;AAWA,IAAI,SAAwB,OAAO,QAAQ,IAAI;IAC7C,MAAM;IACN,SAAS;AACX;AAEA,IAAI,CAAC,OAAO,QAAQ,EAAE;IACpB,OAAO,QAAQ,GAAG;AACpB;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,IAAI;YACF,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAa;QACjD,EAAE,OAAO,OAAO;YACd,OAAO,OAAO,GAAG;YACjB,QAAQ,KAAK,CAAC,mCAAmC;YACjD,MAAM;QACR;IACF;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QAClC,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAY;QACnB,OAAO,OAAO,GAAG;QACjB,QAAQ,KAAK,CAAC,6BAA6B,MAAM,OAAO;QACxD,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,MAAM,OAAO,EAAE;IAClE;AACF;uCAEe"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IUser extends Document {\r\n  email: string;\r\n  name: string;\r\n  password: string;\r\n  role: 'student' | 'staff' | 'technician' | 'admin';\r\n  phone?: string;\r\n  location?: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nconst UserSchema: Schema = new Schema(\r\n  {\r\n    email: { \r\n      type: String, \r\n      required: true, \r\n      unique: true,\r\n      lowercase: true,\r\n      trim: true\r\n    },\r\n    name: { \r\n      type: String, \r\n      required: true \r\n    },\r\n    password: { \r\n      type: String, \r\n      required: true \r\n    },\r\n    role: { \r\n      type: String, \r\n      enum: ['student', 'staff', 'technician', 'admin'],\r\n      default: 'student'\r\n    },\r\n    phone: { \r\n      type: String \r\n    },\r\n    location: { \r\n      type: String \r\n    },\r\n    isActive: { \r\n      type: Boolean, \r\n      default: true \r\n    }\r\n  },\r\n  { \r\n    timestamps: true \r\n  }\r\n);\r\n\r\nexport default mongoose.models.User || mongoose.model<IUser>('User', UserSchema);\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAcA,MAAM,aAAqB,IAAI,mHAAM,CACnC;IACE,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,UAAU;IACZ;IACA,UAAU;QACR,MAAM;QACN,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,MAAM;YAAC;YAAW;YAAS;YAAc;SAAQ;QACjD,SAAS;IACX;IACA,OAAO;QACL,MAAM;IACR;IACA,UAAU;QACR,MAAM;IACR;IACA,UAAU;QACR,MAAM;QACN,SAAS;IACX;AACF,GACA;IACE,YAAY;AACd;uCAGa,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAQ,QAAQ"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport connectDB from \"./db\";\r\nimport User from \"@/models/User\";\r\n\r\nexport const authOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"email\" },\r\n        password: { label: \"Password\", type: \"password\" },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.password) {\r\n          return null;\r\n        }\r\n\r\n        await connectDB();\r\n\r\n        const user = await User.findOne({\r\n          email: credentials.email.toLowerCase(),\r\n          isActive: true,\r\n        });\r\n\r\n        if (!user) {\r\n          return null;\r\n        }\r\n\r\n        const isPasswordValid = await bcrypt.compare(\r\n          credentials.password as string,\r\n          user.password\r\n        );\r\n\r\n        if (!isPasswordValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          id: user._id.toString(),\r\n          email: user.email,\r\n          name: user.name,\r\n          role: user.role,\r\n        };\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }: { token: any; user?: any }) {\r\n      if (user) {\r\n        token.id = user.id;\r\n        token.role = user.role;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }: { session: any; token: any }) {\r\n      if (session.user) {\r\n        session.user.id = token.id || token.sub;\r\n        session.user.role = token.role;\r\n      }\r\n      return session;\r\n    },\r\n  },\r\n  pages: {\r\n    signIn: \"/login\",\r\n  },\r\n  session: {\r\n    strategy: \"jwt\" as const,\r\n  },\r\n};\r\n\r\n// Export auth functions separately for client-side use\r\nexport const { auth, signIn, signOut } = NextAuth(authOptions);\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,MAAM,cAAc;IACzB,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,IAAA,6HAAS;gBAEf,MAAM,OAAO,MAAM,kIAAI,CAAC,OAAO,CAAC;oBAC9B,OAAO,YAAY,KAAK,CAAC,WAAW;oBACpC,UAAU;gBACZ;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,8IAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;oBACrB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAA8B;YACnD,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;YACxB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAgC;YAC5D,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE,IAAI,MAAM,GAAG;gBACvC,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;IACZ;AACF;AAGO,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,kJAAQ,EAAC"}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Projects/Sprintx_hack/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from 'next-auth';\r\nimport { authOptions } from '@/lib/auth';\r\n\r\nconst handler = NextAuth(authOptions);\r\n\r\nexport const GET = handler;\r\nexport const POST = handler;\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC,mIAAW;AAE7B,MAAM,MAAM;AACZ,MAAM,OAAO"}}]
}